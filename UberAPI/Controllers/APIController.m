//
//  APIController.m
//  UberAPI
//
//  This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ) on 05/09/2016
//
#import "APIController.h"

@implementation APIController

/**
* The Products endpoint returns information about the Uber products offered at a given location. The response includes the display name and other details about each product, and lists the products in the proper display order.
* @param  GetProductsTypesInput     Object with all parameters
* @return	Returns the void response from the API call */
- (void) getProductsTypesAsyncWithGetProductsTypesInput:(GetProductsTypesInput*) input
                completionBlock:(CompletedGetProductsTypes) onCompleted
{
    //the base uri for api requests
    NSString* baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* queryBuilder = [NSMutableString stringWithString: baseUri]; 
    [queryBuilder appendString: @"/v1/products"];

    //process optional query parameters
    [APIHelper appendUrl: queryBuilder withQueryParameters: @{
                    @"latitude": [NSNumber numberWithDouble:input.latitude],
                    @"longitude": [NSNumber numberWithDouble:input.longitude]
                }];

    //validate and preprocess url
    NSString* queryUrl = [APIHelper cleanUrl: queryBuilder];

    //preparing request headers
    NSMutableDictionary* headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"Authorization": [NSString stringWithFormat:@"Bearer %@", Configuration_OAuthAccessToken]
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: headers];


    //prepare the request and fetch response  
    HttpRequest* request = [[self clientInstance] get: ^(HttpRequest* request) 
    { 
        [request setQueryUrl: queryUrl]; //set request url        
        [request setHeaders: headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: request
     success: ^(id context, HttpResponse *response) {
         //Error handling using HTTP status codes
         NSError* statusError = nil;

         //Error handling using HTTP status codes 
         if (response.statusCode == 400)
             statusError = [[APIError alloc] initWithReason: @"Malformed request."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 401)
             statusError = [[APIError alloc] initWithReason: @"Unauthorized the request requires user authentication (not logged in)."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 403)
             statusError = [[APIError alloc] initWithReason: @"Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 404)
             statusError = [[APIError alloc] initWithReason: @"Not found."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 406)
             statusError = [[APIError alloc] initWithReason: @"Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 422)
             statusError = [[APIError alloc] initWithReason: @"Invalid request. The request body is parse-able however with invalid content."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 429)
             statusError = [[APIError alloc] initWithReason: @"Too Many Requests. Rate limited."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 500)
             statusError = [[APIError alloc] initWithReason: @"Internal Server Error."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if((response.statusCode < 200) || (response.statusCode > 206)) //[200,206] = HTTP OK
             statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         if(statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, context, nil, statusError);
         }
         else
         {
             //return response to API caller
             NSString* strResult = [(HttpStringResponse*)response body];
             ProductCollection* result = (ProductCollection*) [APIHelper jsonDeserialize: strResult
                toClass: ProductCollection.class];

 
             //announce completion with success
             onCompleted(YES, context, result, nil);
         }
     } failure:^(id context, NSError *error) {
 
         //announce completion with failure
         onCompleted(NO, context, nil, error);
     }];
}

/**
* The Price Estimates endpoint returns an estimated price range for each product offered at a given location. The price estimate is provided as a formatted string with the full price range and the localized currency symbol.
* @param  GetPriceEstimatesInput     Object with all parameters
* @return	Returns the void response from the API call */
- (void) getPriceEstimatesAsyncWithGetPriceEstimatesInput:(GetPriceEstimatesInput*) input
                completionBlock:(CompletedGetPriceEstimates) onCompleted
{
    //the base uri for api requests
    NSString* baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* queryBuilder = [NSMutableString stringWithString: baseUri]; 
    [queryBuilder appendString: @"/v1/estimates/price"];

    //process optional query parameters
    [APIHelper appendUrl: queryBuilder withQueryParameters: @{
                    @"end_latitude": [NSNumber numberWithDouble:input.endLatitude],
                    @"end_longitude": [NSNumber numberWithDouble:input.endLongitude],
                    @"start_latitude": [NSNumber numberWithDouble:input.startLatitude],
                    @"start_longitude": [NSNumber numberWithDouble:input.startLongitude]
                }];

    //validate and preprocess url
    NSString* queryUrl = [APIHelper cleanUrl: queryBuilder];

    //preparing request headers
    NSMutableDictionary* headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"Authorization": [NSString stringWithFormat:@"Bearer %@", Configuration_OAuthAccessToken]
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: headers];


    //prepare the request and fetch response  
    HttpRequest* request = [[self clientInstance] get: ^(HttpRequest* request) 
    { 
        [request setQueryUrl: queryUrl]; //set request url        
        [request setHeaders: headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: request
     success: ^(id context, HttpResponse *response) {
         //Error handling using HTTP status codes
         NSError* statusError = nil;

         //Error handling using HTTP status codes 
         if (response.statusCode == 400)
             statusError = [[APIError alloc] initWithReason: @"Malformed request."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 401)
             statusError = [[APIError alloc] initWithReason: @"Unauthorized the request requires user authentication (not logged in)."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 403)
             statusError = [[APIError alloc] initWithReason: @"Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 404)
             statusError = [[APIError alloc] initWithReason: @"Not found."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 406)
             statusError = [[APIError alloc] initWithReason: @"Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 422)
             statusError = [[APIError alloc] initWithReason: @"Invalid request. The request body is parse-able however with invalid content."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 429)
             statusError = [[APIError alloc] initWithReason: @"Too Many Requests. Rate limited."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 500)
             statusError = [[APIError alloc] initWithReason: @"Internal Server Error."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if((response.statusCode < 200) || (response.statusCode > 206)) //[200,206] = HTTP OK
             statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         if(statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, context, nil, statusError);
         }
         else
         {
             //return response to API caller
             NSString* strResult = [(HttpStringResponse*)response body];
             PriceEstimateCollection* result = (PriceEstimateCollection*) [APIHelper jsonDeserialize: strResult
                toClass: PriceEstimateCollection.class];

 
             //announce completion with success
             onCompleted(YES, context, result, nil);
         }
     } failure:^(id context, NSError *error) {
 
         //announce completion with failure
         onCompleted(NO, context, nil, error);
     }];
}

/**
* The Time Estimates endpoint returns ETAs for all products offered at a given location, with the responses expressed as integers in seconds. We recommend that this endpoint be called every minute to provide the most accurate, up-to-date ETAs.
* @param  GetTimeEstimatesInput     Object with all parameters
* @return	Returns the void response from the API call */
- (void) getTimeEstimatesAsyncWithGetTimeEstimatesInput:(GetTimeEstimatesInput*) input
                completionBlock:(CompletedGetTimeEstimates) onCompleted
{
    //the base uri for api requests
    NSString* baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* queryBuilder = [NSMutableString stringWithString: baseUri]; 
    [queryBuilder appendString: @"/v1/estimates/time"];

    //process optional query parameters
    [APIHelper appendUrl: queryBuilder withQueryParameters: @{
                    @"start_latitude": [NSNumber numberWithDouble:input.startLatitude],
                    @"start_longitude": [NSNumber numberWithDouble:input.startLongitude],
                    @"customer_uuid": (nil != input.customerUuid) ? input.customerUuid : [NSNull null],
                    @"product_id": (nil != input.productId) ? input.productId : [NSNull null]
                }];

    //validate and preprocess url
    NSString* queryUrl = [APIHelper cleanUrl: queryBuilder];

    //preparing request headers
    NSMutableDictionary* headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"Authorization": [NSString stringWithFormat:@"Bearer %@", Configuration_OAuthAccessToken]
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: headers];


    //prepare the request and fetch response  
    HttpRequest* request = [[self clientInstance] get: ^(HttpRequest* request) 
    { 
        [request setQueryUrl: queryUrl]; //set request url        
        [request setHeaders: headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: request
     success: ^(id context, HttpResponse *response) {
         //Error handling using HTTP status codes
         NSError* statusError = nil;

         //Error handling using HTTP status codes 
         if (response.statusCode == 400)
             statusError = [[APIError alloc] initWithReason: @"Malformed request."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 401)
             statusError = [[APIError alloc] initWithReason: @"Unauthorized the request requires user authentication (not logged in)."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 403)
             statusError = [[APIError alloc] initWithReason: @"Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 404)
             statusError = [[APIError alloc] initWithReason: @"Not found."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 406)
             statusError = [[APIError alloc] initWithReason: @"Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 422)
             statusError = [[APIError alloc] initWithReason: @"Invalid request. The request body is parse-able however with invalid content."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 429)
             statusError = [[APIError alloc] initWithReason: @"Too Many Requests. Rate limited."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 500)
             statusError = [[APIError alloc] initWithReason: @"Internal Server Error."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if((response.statusCode < 200) || (response.statusCode > 206)) //[200,206] = HTTP OK
             statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         if(statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, context, nil, statusError);
         }
         else
         {
             //return response to API caller
             NSString* strResult = [(HttpStringResponse*)response body];
             TimeEstimateCollection* result = (TimeEstimateCollection*) [APIHelper jsonDeserialize: strResult
                toClass: TimeEstimateCollection.class];

 
             //announce completion with success
             onCompleted(YES, context, result, nil);
         }
     } failure:^(id context, NSError *error) {
 
         //announce completion with failure
         onCompleted(NO, context, nil, error);
     }];
}

/**
* The User Activity endpoint returns data about a user's lifetime activity with Uber. The response will include pickup locations and times, dropoff locations and times, the distance of past requests, and information about which products were requested.
* @param  GetUserActivityV11Input     Object with all parameters
* @return	Returns the void response from the API call */
- (void) getUserActivityV11AsyncWithGetUserActivityV11Input:(GetUserActivityV11Input*) input
                completionBlock:(CompletedGetUserActivityV11) onCompleted
{
    //the base uri for api requests
    NSString* baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* queryBuilder = [NSMutableString stringWithString: baseUri]; 
    [queryBuilder appendString: @"/v1.1/history"];

    //process optional query parameters
    [APIHelper appendUrl: queryBuilder withQueryParameters: @{
                    @"limit": [NSNumber numberWithInteger:input.limit],
                    @"offset": [NSNumber numberWithInteger:input.offset]
                }];

    //validate and preprocess url
    NSString* queryUrl = [APIHelper cleanUrl: queryBuilder];

    //preparing request headers
    NSMutableDictionary* headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"Authorization": [NSString stringWithFormat:@"Bearer %@", Configuration_OAuthAccessToken]
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: headers];


    //prepare the request and fetch response  
    HttpRequest* request = [[self clientInstance] get: ^(HttpRequest* request) 
    { 
        [request setQueryUrl: queryUrl]; //set request url        
        [request setHeaders: headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: request
     success: ^(id context, HttpResponse *response) {
         //Error handling using HTTP status codes
         NSError* statusError = nil;

         //Error handling using HTTP status codes 
         if (response.statusCode == 400)
             statusError = [[APIError alloc] initWithReason: @"Malformed request."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 401)
             statusError = [[APIError alloc] initWithReason: @"Unauthorized the request requires user authentication (not logged in)."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 403)
             statusError = [[APIError alloc] initWithReason: @"Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 404)
             statusError = [[APIError alloc] initWithReason: @"Not found."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 406)
             statusError = [[APIError alloc] initWithReason: @"Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 422)
             statusError = [[APIError alloc] initWithReason: @"Invalid request. The request body is parse-able however with invalid content."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 429)
             statusError = [[APIError alloc] initWithReason: @"Too Many Requests. Rate limited."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 500)
             statusError = [[APIError alloc] initWithReason: @"Internal Server Error."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if((response.statusCode < 200) || (response.statusCode > 206)) //[200,206] = HTTP OK
             statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         if(statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, context, nil, statusError);
         }
         else
         {
             //return response to API caller
             NSString* strResult = [(HttpStringResponse*)response body];
             UserActivity* result = (UserActivity*) [APIHelper jsonDeserialize: strResult
                toClass: UserActivity.class];

 
             //announce completion with success
             onCompleted(YES, context, result, nil);
         }
     } failure:^(id context, NSError *error) {
 
         //announce completion with failure
         onCompleted(NO, context, nil, error);
     }];
}

/**
* The User Profile endpoint returns information about the Uber user that has authorized with the application.
* @return	Returns the void response from the API call */
- (void) getUserProfileWithCompletionBlock:(CompletedGetUserProfile) onCompleted
{
    //the base uri for api requests
    NSString* baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* queryBuilder = [NSMutableString stringWithString: baseUri]; 
    [queryBuilder appendString: @"/v1/me"];

    //validate and preprocess url
    NSString* queryUrl = [APIHelper cleanUrl: queryBuilder];

    //preparing request headers
    NSMutableDictionary* headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"Authorization": [NSString stringWithFormat:@"Bearer %@", Configuration_OAuthAccessToken]
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: headers];


    //prepare the request and fetch response  
    HttpRequest* request = [[self clientInstance] get: ^(HttpRequest* request) 
    { 
        [request setQueryUrl: queryUrl]; //set request url        
        [request setHeaders: headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: request
     success: ^(id context, HttpResponse *response) {
         //Error handling using HTTP status codes
         NSError* statusError = nil;

         //Error handling using HTTP status codes 
         if (response.statusCode == 400)
             statusError = [[APIError alloc] initWithReason: @"Malformed request."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 401)
             statusError = [[APIError alloc] initWithReason: @"Unauthorized the request requires user authentication (not logged in)."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 403)
             statusError = [[APIError alloc] initWithReason: @"Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 404)
             statusError = [[APIError alloc] initWithReason: @"Not found."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 406)
             statusError = [[APIError alloc] initWithReason: @"Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 422)
             statusError = [[APIError alloc] initWithReason: @"Invalid request. The request body is parse-able however with invalid content."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 429)
             statusError = [[APIError alloc] initWithReason: @"Too Many Requests. Rate limited."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 500)
             statusError = [[APIError alloc] initWithReason: @"Internal Server Error."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if((response.statusCode < 200) || (response.statusCode > 206)) //[200,206] = HTTP OK
             statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         if(statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, context, nil, statusError);
         }
         else
         {
             //return response to API caller
             NSString* strResult = [(HttpStringResponse*)response body];
             UserProfile* result = (UserProfile*) [APIHelper jsonDeserialize: strResult
                toClass: UserProfile.class];

 
             //announce completion with success
             onCompleted(YES, context, result, nil);
         }
     } failure:^(id context, NSError *error) {
 
         //announce completion with failure
         onCompleted(NO, context, nil, error);
     }];
}

/**
* Get product details w.r.t id
* @param    productId    Required parameter: Unique identifier representing a specific product for a given latitude & longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles.
* @return	Returns the void response from the API call */
- (void) getProductDetailByIDAsyncWithProductId:(NSString*) productId
                completionBlock:(CompletedGetProductDetailByID) onCompleted
{
    //the base uri for api requests
    NSString* baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* queryBuilder = [NSMutableString stringWithString: baseUri]; 
    [queryBuilder appendString: @"/v1/products/{product_id}"];

    //process optional query parameters
    [APIHelper appendUrl: queryBuilder withTemplateParameters: @{
                    @"product_id": productId
                }];

    //validate and preprocess url
    NSString* queryUrl = [APIHelper cleanUrl: queryBuilder];

    //preparing request headers
    NSMutableDictionary* headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"Authorization": [NSString stringWithFormat:@"Bearer %@", Configuration_OAuthAccessToken]
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: headers];


    //prepare the request and fetch response  
    HttpRequest* request = [[self clientInstance] get: ^(HttpRequest* request) 
    { 
        [request setQueryUrl: queryUrl]; //set request url        
        [request setHeaders: headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: request
     success: ^(id context, HttpResponse *response) {
         //Error handling using HTTP status codes
         NSError* statusError = nil;

         //Error handling using HTTP status codes 
         if((response.statusCode < 200) || (response.statusCode > 206)) //[200,206] = HTTP OK
             statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         if(statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, context, nil, statusError);
         }
         else
         {
             //return response to API caller
             NSString* strResult = [(HttpStringResponse*)response body];
             Product* result = (Product*) [APIHelper jsonDeserialize: strResult
                toClass: Product.class];

 
             //announce completion with success
             onCompleted(YES, context, result, nil);
         }
     } failure:^(id context, NSError *error) {
 
         //announce completion with failure
         onCompleted(NO, context, nil, error);
     }];
}

/**
* The Promotions endpoint returns information about the promotion that will be available to a new user based on their activity's location. These promotions do not apply for existing users.
* @param  GetPromotionsInput     Object with all parameters
* @return	Returns the void response from the API call */
- (void) getPromotionsAsyncWithGetPromotionsInput:(GetPromotionsInput*) input
                completionBlock:(CompletedGetPromotions) onCompleted
{
    //the base uri for api requests
    NSString* baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* queryBuilder = [NSMutableString stringWithString: baseUri]; 
    [queryBuilder appendString: @"/v1/promotions"];

    //process optional query parameters
    [APIHelper appendUrl: queryBuilder withQueryParameters: @{
                    @"end_latitude": [NSNumber numberWithDouble:input.endLatitude],
                    @"end_longitude": [NSNumber numberWithDouble:input.endLongitude],
                    @"start_latitude": [NSNumber numberWithDouble:input.startLatitude],
                    @"start_longitude": [NSNumber numberWithDouble:input.startLongitude]
                }];

    //validate and preprocess url
    NSString* queryUrl = [APIHelper cleanUrl: queryBuilder];

    //preparing request headers
    NSMutableDictionary* headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"Authorization": [NSString stringWithFormat:@"Bearer %@", Configuration_OAuthAccessToken]
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: headers];


    //prepare the request and fetch response  
    HttpRequest* request = [[self clientInstance] get: ^(HttpRequest* request) 
    { 
        [request setQueryUrl: queryUrl]; //set request url        
        [request setHeaders: headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: request
     success: ^(id context, HttpResponse *response) {
         //Error handling using HTTP status codes
         NSError* statusError = nil;

         //Error handling using HTTP status codes 
         if (response.statusCode == 400)
             statusError = [[APIError alloc] initWithReason: @"Malformed request."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 401)
             statusError = [[APIError alloc] initWithReason: @"Unauthorized the request requires user authentication (not logged in)."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 403)
             statusError = [[APIError alloc] initWithReason: @"Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 404)
             statusError = [[APIError alloc] initWithReason: @"Not found."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 406)
             statusError = [[APIError alloc] initWithReason: @"Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 409)
             statusError = [[APIError alloc] initWithReason: @"A conflict needs to be resolved before the request can be made."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 422)
             statusError = [[APIError alloc] initWithReason: @"Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 429)
             statusError = [[APIError alloc] initWithReason: @"Too Many Requests. Rate limited"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 500)
             statusError = [[APIError alloc] initWithReason: @"Internal Server Error."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 222)
             statusError = [[APIError alloc] initWithReason: @"bac"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if((response.statusCode < 200) || (response.statusCode > 206)) //[200,206] = HTTP OK
             statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         if(statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, context, nil, statusError);
         }
         else
         {
             //return response to API caller
             NSString* strResult = [(HttpStringResponse*)response body];
             PromotionsResponse* result = (PromotionsResponse*) [APIHelper jsonDeserialize: strResult
                toClass: PromotionsResponse.class];

 
             //announce completion with success
             onCompleted(YES, context, result, nil);
         }
     } failure:^(id context, NSError *error) {
 
         //announce completion with failure
         onCompleted(NO, context, nil, error);
     }];
}

/**
* The Request endpoint allows a ride to be requested on behalf of an Uber user given their desired product, start, and end locations. Please review the Sandbox documentation on how to develop and test against these endpoints without making real-world Requests and being charged.
* @param    body    Required parameter: TODO: type description here
* @return	Returns the void response from the API call */
- (void) createRequestAsyncWithBody:(RequestBody*) body
                completionBlock:(CompletedPostRequest) onCompleted
{
    //the base uri for api requests
    NSString* baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* queryBuilder = [NSMutableString stringWithString: baseUri]; 
    [queryBuilder appendString: @"/v1/requests"];

    //validate and preprocess url
    NSString* queryUrl = [APIHelper cleanUrl: queryBuilder];

    //preparing request headers
    NSMutableDictionary* headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"content-type": @"application/json; charset=utf-8",
        @"Authorization": [NSString stringWithFormat:@"Bearer %@", Configuration_OAuthAccessToken]
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: headers];


    //prepare the request and fetch response 
    HttpRequest* request = [[self clientInstance] postBody: ^(HttpBodyRequest* request)
    {
        [request setBody: [[APIHelper jsonSerialize: body] dataUsingEncoding:NSUTF8StringEncoding]]; //set request body
        [request setQueryUrl: queryUrl]; //set request url        
        [request setHeaders: headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: request
     success: ^(id context, HttpResponse *response) {
         //Error handling using HTTP status codes
         NSError* statusError = nil;

         //Error handling using HTTP status codes 
         if (response.statusCode == 400)
             statusError = [[APIError alloc] initWithReason: @"Malformed request"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 401)
             statusError = [[APIError alloc] initWithReason: @"Unauthorized the request requires user authentication (not logged in)."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 403)
             statusError = [[APIError alloc] initWithReason: @"Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 404)
             statusError = [[APIError alloc] initWithReason: @"Not found"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 406)
             statusError = [[APIError alloc] initWithReason: @"Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 409)
             statusError = [[APIError alloc] initWithReason: @"A conflict needs to be resolved before the request can be made."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 422)
             statusError = [[APIError alloc] initWithReason: @"Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 429)
             statusError = [[APIError alloc] initWithReason: @"Too Many Requests. Rate limited."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 500)
             statusError = [[APIError alloc] initWithReason: @"Internal Server Error."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if((response.statusCode < 200) || (response.statusCode > 206)) //[200,206] = HTTP OK
             statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         if(statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, context, nil, statusError);
         }
         else
         {
             //return response to API caller
             NSString* strResult = [(HttpStringResponse*)response body];
             Request* result = (Request*) [APIHelper jsonDeserialize: strResult
                toClass: Request.class];

 
             //announce completion with success
             onCompleted(YES, context, result, nil);
         }
     } failure:^(id context, NSError *error) {
 
         //announce completion with failure
         onCompleted(NO, context, nil, error);
     }];
}

/**
* Get the real time status of an ongoing trip that was created using the Ride Request endpoint.
* @param    requestId    Required parameter: TODO: type description here
* @return	Returns the void response from the API call */
- (void) getRequestDetailsAsyncWithRequestId:(NSString*) requestId
                completionBlock:(CompletedGetRequestDetails) onCompleted
{
    //the base uri for api requests
    NSString* baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* queryBuilder = [NSMutableString stringWithString: baseUri]; 
    [queryBuilder appendString: @"/v1/requests/{request_id}"];

    //process optional query parameters
    [APIHelper appendUrl: queryBuilder withTemplateParameters: @{
                    @"request_id": requestId
                }];

    //validate and preprocess url
    NSString* queryUrl = [APIHelper cleanUrl: queryBuilder];

    //preparing request headers
    NSMutableDictionary* headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"Authorization": [NSString stringWithFormat:@"Bearer %@", Configuration_OAuthAccessToken]
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: headers];


    //prepare the request and fetch response  
    HttpRequest* request = [[self clientInstance] get: ^(HttpRequest* request) 
    { 
        [request setQueryUrl: queryUrl]; //set request url        
        [request setHeaders: headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: request
     success: ^(id context, HttpResponse *response) {
         //Error handling using HTTP status codes
         NSError* statusError = nil;

         //Error handling using HTTP status codes 
         if (response.statusCode == 400)
             statusError = [[APIError alloc] initWithReason: @"Malformed request."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 401)
             statusError = [[APIError alloc] initWithReason: @"Unauthorized the request requires user authentication (not logged in)."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 403)
             statusError = [[APIError alloc] initWithReason: @"Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 404)
             statusError = [[APIError alloc] initWithReason: @"Not found."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 406)
             statusError = [[APIError alloc] initWithReason: @"Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 409)
             statusError = [[APIError alloc] initWithReason: @"A conflict needs to be resolved before the request can be made."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 422)
             statusError = [[APIError alloc] initWithReason: @"Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 429)
             statusError = [[APIError alloc] initWithReason: @"Too Many Requests. Rate limited."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 500)
             statusError = [[APIError alloc] initWithReason: @"Internal Server Error"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if((response.statusCode < 200) || (response.statusCode > 206)) //[200,206] = HTTP OK
             statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         if(statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, context, nil, statusError);
         }
         else
         {
             //return response to API caller
             NSString* strResult = [(HttpStringResponse*)response body];
             RequestDetailsCollections* result = (RequestDetailsCollections*) [APIHelper jsonDeserialize: strResult
                toClass: RequestDetailsCollections.class];

 
             //announce completion with success
             onCompleted(YES, context, result, nil);
         }
     } failure:^(id context, NSError *error) {
 
         //announce completion with failure
         onCompleted(NO, context, nil, error);
     }];
}

/**
* Cancel an ongoing Request on behalf of a rider.
* @param    requestId    Required parameter: Unique identifier representing a Request.
* @return	Returns the void response from the API call */
- (void) deleteRequestCancelAsyncWithRequestId:(NSString*) requestId
                completionBlock:(CompletedDeleteRequestCancel) onCompleted
{
    //the base uri for api requests
    NSString* baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* queryBuilder = [NSMutableString stringWithString: baseUri]; 
    [queryBuilder appendString: @"/v1/requests/{request_id}"];

    //process optional query parameters
    [APIHelper appendUrl: queryBuilder withTemplateParameters: @{
                    @"request_id": requestId
                }];

    //validate and preprocess url
    NSString* queryUrl = [APIHelper cleanUrl: queryBuilder];

    //preparing request headers
    NSMutableDictionary* headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"Authorization": [NSString stringWithFormat:@"Bearer %@", Configuration_OAuthAccessToken]
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: headers];


    //prepare the request and fetch response  
    HttpRequest* request = [[self clientInstance] delete: ^(HttpRequest* request) 
    { 
        [request setQueryUrl: queryUrl]; //set request url        
        [request setHeaders: headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: request
     success: ^(id context, HttpResponse *response) {
         //Error handling using HTTP status codes
         NSError* statusError = nil;

         //Error handling using HTTP status codes 
         if (response.statusCode == 400)
             statusError = [[APIError alloc] initWithReason: @"Malformed request."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 401)
             statusError = [[APIError alloc] initWithReason: @"Unauthorized the request requires user authentication (not logged in)."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 403)
             statusError = [[APIError alloc] initWithReason: @"Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 404)
             statusError = [[APIError alloc] initWithReason: @"Not found"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 406)
             statusError = [[APIError alloc] initWithReason: @"Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 409)
             statusError = [[APIError alloc] initWithReason: @"A conflict needs to be resolved before the request can be made"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 422)
             statusError = [[APIError alloc] initWithReason: @"Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 429)
             statusError = [[APIError alloc] initWithReason: @"Too Many Requests. Rate limited."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 500)
             statusError = [[APIError alloc] initWithReason: @"Internal Server Error"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if((response.statusCode < 200) || (response.statusCode > 206)) //[200,206] = HTTP OK
             statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         if(statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, context, statusError);
         }
         else
         {
             //return response to API caller

         }
     } failure:^(id context, NSError *error) {
 
         //announce completion with failure
         onCompleted(NO, context, error);
     }];
}

/**
* Get a map with a visual representation of a Request.
* @param    requestId    Required parameter: Unique identifier representing a Request.
* @return	Returns the void response from the API call */
- (void) getRequestMapAsyncWithRequestId:(NSString*) requestId
                completionBlock:(CompletedGetRequestMap) onCompleted
{
    //the base uri for api requests
    NSString* baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* queryBuilder = [NSMutableString stringWithString: baseUri]; 
    [queryBuilder appendString: @"/v1/requests/{request_id}/map"];

    //process optional query parameters
    [APIHelper appendUrl: queryBuilder withTemplateParameters: @{
                    @"request_id": requestId
                }];

    //validate and preprocess url
    NSString* queryUrl = [APIHelper cleanUrl: queryBuilder];

    //preparing request headers
    NSMutableDictionary* headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"Authorization": [NSString stringWithFormat:@"Bearer %@", Configuration_OAuthAccessToken]
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: headers];


    //prepare the request and fetch response  
    HttpRequest* request = [[self clientInstance] get: ^(HttpRequest* request) 
    { 
        [request setQueryUrl: queryUrl]; //set request url        
        [request setHeaders: headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: request
     success: ^(id context, HttpResponse *response) {
         //Error handling using HTTP status codes
         NSError* statusError = nil;

         //Error handling using HTTP status codes 
         if (response.statusCode == 400)
             statusError = [[APIError alloc] initWithReason: @"Malformed request."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 401)
             statusError = [[APIError alloc] initWithReason: @"Unauthorized the request requires user authentication (not logged in)."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 403)
             statusError = [[APIError alloc] initWithReason: @"Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 404)
             statusError = [[APIError alloc] initWithReason: @"Not found"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 406)
             statusError = [[APIError alloc] initWithReason: @"Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 409)
             statusError = [[APIError alloc] initWithReason: @"A conflict needs to be resolved before the request can be made."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 422)
             statusError = [[APIError alloc] initWithReason: @"Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 429)
             statusError = [[APIError alloc] initWithReason: @"Too Many Requests. Rate limited."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if (response.statusCode == 500)
             statusError = [[APIError alloc] initWithReason: @"Internal Server Error."
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         else if((response.statusCode < 200) || (response.statusCode > 206)) //[200,206] = HTTP OK
             statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         if(statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, context, nil, statusError);
         }
         else
         {
             //return response to API caller
             NSString* strResult = [(HttpStringResponse*)response body];
             RequestMapResponse* result = (RequestMapResponse*) [APIHelper jsonDeserialize: strResult
                toClass: RequestMapResponse.class];

 
             //announce completion with success
             onCompleted(YES, context, result, nil);
         }
     } failure:^(id context, NSError *error) {
 
         //announce completion with failure
         onCompleted(NO, context, nil, error);
     }];
}


@end